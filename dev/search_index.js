var documenterSearchIndex = {"docs":
[{"location":"api/PowerSimulations.html#PowerSimulations-1","page":"PowerSimulations","title":"PowerSimulations","text":"","category":"section"},{"location":"api/PowerSimulations.html#","page":"PowerSimulations","title":"PowerSimulations","text":"CurrentModule = PowerSimulations\nDocTestSetup  = quote\n    using PowerSimulations\nend","category":"page"},{"location":"api/PowerSimulations.html#","page":"PowerSimulations","title":"PowerSimulations","text":"API documentation","category":"page"},{"location":"api/PowerSimulations.html#","page":"PowerSimulations","title":"PowerSimulations","text":"Pages = [\"PowerSimulations.md\"]","category":"page"},{"location":"api/PowerSimulations.html#Index-1","page":"PowerSimulations","title":"Index","text":"","category":"section"},{"location":"api/PowerSimulations.html#","page":"PowerSimulations","title":"PowerSimulations","text":"Pages = [\"PowerSimulations.md\"]","category":"page"},{"location":"api/PowerSimulations.html#Exported-1","page":"PowerSimulations","title":"Exported","text":"","category":"section"},{"location":"api/PowerSimulations.html#","page":"PowerSimulations","title":"PowerSimulations","text":"Modules = [PowerSimulations]\nPrivate = false","category":"page"},{"location":"api/PowerSimulations.html#PowerSimulations.DeviceModel","page":"PowerSimulations","title":"PowerSimulations.DeviceModel","text":"DeviceModel(::Type{D}, ::Type{B}) where {D<:PSY.Device,\n                                   B<:AbstractDeviceFormulation}\n\nThis validates the device formulation for the Power System Device and the abstract device formulation and returns  Power System Device and the abstract device formulation if the power system device is a concrete type.\n\nArguments\n\n-::Type{D}: Power System Device -::Type{B}: Abstract Device Formulation\n\nOutputs\n\nDeviceModel(D, B, nothing): D::PSY.Device, B::AbstractDeviceFormulation\n\nExample\n\nbranches = Dict{Symbol, DeviceModel}\n    (:L => DeviceModel(PSY.Line, StaticLine),\n    :T => DeviceModel(PSY.Transformer2W, StaticTransformer),\n    :TT => DeviceModel(PSY.TapTransformer , StaticTransformer),\n    :dc_line => DeviceModel(PSY.HVDCLine, HVDCDispatch))\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations.html#PowerSimulations.IntraStageChronology","page":"PowerSimulations","title":"PowerSimulations.IntraStageChronology","text":"InterStageChronology()\n\nType struct to select an information sharing model between stages that uses results from the same recent stage to calculate the initial conditions. This model ignores solutions from stages defined finer resolutions.\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations.html#PowerSimulations.OperationsProblem-Union{Tuple{M}, Tuple{Type{M},OperationsProblemTemplate,PowerSystems.System}} where M<:PowerSimulations.AbstractOperationsProblem","page":"PowerSimulations","title":"PowerSimulations.OperationsProblem","text":"OperationsProblem(::Type{M},\ntemplate::OperationsProblemTemplate,\nsys::PSY.System;\noptimizer::Union{Nothing, JuMP.MOI.OptimizerWithAttributes}=nothing,\nkwargs...) where {M<:AbstractOperationsProblem,\n                  T<:PM.AbstractPowerFormulation}\n\nThis builds the optimization problem with the specific system and template.\n\nArguments\n\n::Type{M} where {M<:AbstractOperationsProblem, T<:PM.AbstractPowerFormulation} = TestOpProblem:\n\nThe abstract operation model type\n\ntemplate::OperationsProblemTemplate: The model reference made up of transmission, devices,                                         branches, and services.\nsys::PSY.System: the system created using Power Systems\n\nOutput\n\nop_problem::OperationsProblem: The operation model contains the model type, model, Power\n\nSystems system, and optimization model.\n\nExample\n\ntemplate = OperationsProblemTemplate(CopperPlatePowerModel, devices, branches, services)\nOpModel = OperationsProblem(TestOpProblem, template, system; optimizer = optimizer)\n\nAccepted Key Words\n\nPTDF::PTDF: Passes the PTDF matrix into the optimization model\noptimizer::union{Nothing, JuMP.MOI.OptimizerWithAttributes} = GLPK_optimizer: The optimizer gets passed\n\ninto the optimization model the default is nothing.\n\ninitial_conditions::InitialConditionsContainer: default of Dict{ICKey, Array{InitialCondition}}\nparameters::Bool: enable JuMP parameters\nuse_forecast_data::Bool: if true, forecast collects the time steps in Power Systems,\n\nif false it runs for one time step\n\ninitial_time::Dates.DateTime: initial time of forecast\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.OperationsProblem-Union{Tuple{T}, Tuple{M}, Tuple{Type{M},Type{T},PowerSystems.System}} where T<:PowerModels.AbstractPowerModel where M<:PowerSimulations.AbstractOperationsProblem","page":"PowerSimulations","title":"PowerSimulations.OperationsProblem","text":"OperationsProblem(op_problem::Type{M},\n                ::Type{T},\n                sys::PSY.System;\n                kwargs...) where {M<:AbstractOperationsProblem,\n                                T<:PM.AbstractPowerFormulation}\n\nThis uses the Abstract Power Formulation to build the model reference and the optimization model and populates the operation model struct.\n\nArguments\n\nop_problem::Type{M} = where {M<:AbstractOperationsProblem: Defines the type of the operation model\n::Type{T} where T<:PM.AbstractPowerFormulation: The power formulation used for model ref & optimization model\nsys::PSY.System: the system created in Power Systems\n\nOutput\n\nop_problem::OperationsProblem: The operation model contains the model type, model, Power\n\nSystems system, and optimization model.\n\nExample\n\ntemplate = OperationsProblemTemplate(CopperPlatePowerModel, devices, branches, services)\nOpModel = OperationsProblem(TestOpProblem, template, system; optimizer = optimizer)\n\nAccepted Key Words\n\nPTDF::PTDF: Passes the PTDF matrix into the optimization model\noptimizer::union{Nothing, JuMP.MOI.OptimizerWithAttributes}: The optimizer gets passed\n\ninto the optimization model the default is nothing.\n\ninitial_conditions::InitialConditionsContainer: default of Dict{ICKey, Array{InitialCondition}}\nparameters::Bool: enable JuMP parameters\nuse_forecast_data::Bool: if true, forecast collects the time steps in Power Systems,\n\nif false it runs for one time step\n\ninitial_time::Dates.DateTime: initial time of forecast\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.OperationsProblem-Union{Tuple{T}, Tuple{Type{T},PowerSystems.System}} where T<:PowerModels.AbstractPowerModel","page":"PowerSimulations","title":"PowerSimulations.OperationsProblem","text":"OperationsProblem(::Type{T},\n                sys::PSY.System;\n                kwargs...) where {M<:AbstractOperationsProblem,\n                                  T<:PM.AbstractPowerFormulation}\n\nThis uses the Abstract Power Formulation to build the model reference and the optimization model and populates the operation model struct. ***Note:*** the abstract operation model is set to the default operation model\n\nArguments\n\nop_problem::Type{M}: Defines the type of the operation model\n::Type{T} where T<:PM.AbstractPowerFormulation: The power formulation used for model ref & optimization model\nsys::PSY.System: the system created in Power Systems\n\nOutput\n\nop_problem::OperationsProblem: The operation model contains the model type, model, Power\n\nSystems system, and optimization model.\n\nExample\n\ntemplate = OperationsProblemTemplate(CopperPlatePowerModel, devices, branches, services)\nOpModel = OperationsProblem(TestOpProblem, template, system; optimizer = optimizer)\n\nAccepted Key Words\n\nPTDF::PTDF: Passes the PTDF matrix into the optimization model\noptimizer::union{Nothing, JuMP.MOI.OptimizerWithAttributes}: The optimizer gets passed\n\ninto the optimization model the default is nothing.\n\ninitial_conditions::InitialConditionsContainer: default of Dict{ICKey, Array{InitialCondition}}\nparameters::Bool: enable JuMP parameters\nuse_forecast_data::Bool: if true, forecast collects the time steps in Power Systems,\n\nif false it runs for one time step\n\ninitial_time::Dates.DateTime: initial time of forecast\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.OperationsProblemTemplate-Union{Tuple{Type{T}}, Tuple{T}} where T<:PowerModels.AbstractPowerModel","page":"PowerSimulations","title":"PowerSimulations.OperationsProblemTemplate","text":"OperationsProblemTemplate(::Type{T}) where {T<:PM.AbstractPowerFormulation}\n\nCreates a model reference of the Power Formulation, devices, branches, and services.\n\nArguments\n\nmodel::Type{T<:PM.AbstractPowerFormulation}:\ndevices::Dict{Symbol, DeviceModel}: device dictionary\nbranches::Dict{Symbol, BranchModel}: branch dictionary\nservices::Dict{Symbol, ServiceModel}: service dictionary\n\nExample\n\ntemplate = OperationsProblemTemplate(CopperPlatePowerModel, devices, branches, services)\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.RecedingHorizon","page":"PowerSimulations","title":"PowerSimulations.RecedingHorizon","text":"RecedingHorizon(period::Int)\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations.html#PowerSimulations.Simulation","page":"PowerSimulations","title":"PowerSimulations.Simulation","text":"Simulation(steps::Int\n            stages::Dict{String, Stage{<:AbstractOperationsProblem}}\n            sequence::Union{Nothing, SimulationSequence}\n            simulation_folder::String\n            name::String\n            internal::Union{Nothing, SimulationInternal}\n            )\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations.html#PowerSimulations.SimulationSequence","page":"PowerSimulations","title":"PowerSimulations.SimulationSequence","text":"SimulationSequence(initial_time::Union{Dates.DateTime, Nothing}\n                    horizons::Dict{String, Int}\n                    intervals::Dict{String, <:Tuple{<:Dates.TimePeriod, <:FeedForwardChronology}}\n                    order::Dict{Int, String}\n                    feedforward_chronologies::Dict{Pair{String, String}, <:FeedForwardChronology}\n                    feedforward::Dict{Tuple{String, Symbol, Symbol}, <:AbstractAffectFeedForward}\n                    ini_cond_chronology::Dict{String, <:FeedForwardChronology}\n                    cache::Dict{String, Vector{<:AbstractCache}}\n                    )\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations.html#PowerSimulations.Stage","page":"PowerSimulations","title":"PowerSimulations.Stage","text":"Stage({M<:AbstractOperationsProblem}\n    template::OperationsProblemTemplate\n    sys::PSY.System\n    optimizer::JuMP.MOI.OptimizerWithAttributes\n    internal::Union{Nothing, StageInternal}\n    )\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations.html#PowerSimulations.Synchronize","page":"PowerSimulations","title":"PowerSimulations.Synchronize","text":"Synchronize(periods::Int)\n\nDefines the co-ordination of time between Two stages.\n\nArguments\n\nperiods::Int: Number of time periods to grab data from\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations.html#PowerSimulations.TimeStatusChange","page":"PowerSimulations","title":"PowerSimulations.TimeStatusChange","text":"Tracks the last time status of a device changed in a simulation\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations.html#InfrastructureSystems.write_results-Tuple{PowerSimulations.OperationsProblemResults,String}","page":"PowerSimulations","title":"InfrastructureSystems.write_results","text":"write_results(results::IS.Results, save_path::String)\n\nExports Operational Problem Results to a path\n\nArguments\n\nresults::OperationsProblemResults: results from the simulation\nsave_path::String: folder path where the files will be written\n\nAccepted Key Words\n\nfile_type = CSV: only CSV and featherfile are accepted\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.build!-Tuple{Simulation}","page":"PowerSimulations","title":"PowerSimulations.build!","text":"    build!(sim::Simulation;\n            kwargs...)\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.check_file_integrity-Tuple{String}","page":"PowerSimulations","title":"PowerSimulations.check_file_integrity","text":"check_file_integrity(path::String)\n\nChecks the hash value for each file made with the file is written with the new hash_value to verify the file hasn't been tampered with since written\n\nArguments\n\npath::String: this is the folder path that contains the results and the check.sha256 file\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,PowerSystems.System,DeviceModel{T,D},Type{S}}} where S<:PowerModels.AbstractActivePowerModel where D<:PowerSimulations.AbstractThermalFormulation where T<:PowerSystems.ThermalGen","page":"PowerSimulations","title":"PowerSimulations.construct_device!","text":"This function creates the model for a full themal dispatch formulation depending on combination of devices, deviceformulation and systemformulation\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,PowerSystems.System,DeviceModel{T,D},Type{S}}} where S<:PowerModels.AbstractPowerModel where D<:PowerSimulations.AbstractThermalFormulation where T<:PowerSystems.ThermalGen","page":"PowerSimulations","title":"PowerSimulations.construct_device!","text":"This function creates the model for a full themal dispatch formulation depending on combination of devices, deviceformulation and systemformulation\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,PowerSystems.System,DeviceModel{T,ThermalBasicUnitCommitment},Type{S}}} where S<:PowerModels.AbstractActivePowerModel where T<:PowerSystems.ThermalGen","page":"PowerSimulations","title":"PowerSimulations.construct_device!","text":"This function creates the model for a full themal dispatch formulation depending on combination of devices, deviceformulation and systemformulation\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,PowerSystems.System,DeviceModel{T,ThermalBasicUnitCommitment},Type{S}}} where S<:PowerModels.AbstractPowerModel where T<:PowerSystems.ThermalGen","page":"PowerSimulations","title":"PowerSimulations.construct_device!","text":"This function creates the model for a full themal dispatch formulation depending on combination of devices, deviceformulation and systemformulation\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,PowerSystems.System,DeviceModel{T,ThermalRampLimited},Type{S}}} where S<:PowerModels.AbstractActivePowerModel where T<:PowerSystems.ThermalGen","page":"PowerSimulations","title":"PowerSimulations.construct_device!","text":"This function creates the model for a full themal dispatch formulation depending on combination of devices, deviceformulation and systemformulation\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,PowerSystems.System,DeviceModel{T,ThermalRampLimited},Type{S}}} where S<:PowerModels.AbstractPowerModel where T<:PowerSystems.ThermalGen","page":"PowerSimulations","title":"PowerSimulations.construct_device!","text":"This function creates the model for a full themal dispatch formulation depending on combination of devices, deviceformulation and systemformulation\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.get_all_constraint_index-Tuple{OperationsProblem}","page":"PowerSimulations","title":"PowerSimulations.get_all_constraint_index","text":"\"Each Tuple corresponds to (conname, internalindex, moi_index)\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.get_all_var_index-Tuple{OperationsProblem}","page":"PowerSimulations","title":"PowerSimulations.get_all_var_index","text":"\"Each Tuple corresponds to (conname, internalindex, moi_index)\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.load_operation_results-Tuple{AbstractString}","page":"PowerSimulations","title":"PowerSimulations.load_operation_results","text":"results = load_operation_results(path)\n\nThis function can be used to load results from a folder of results from a single-step problem, or for a single foulder within a simulation.\n\nArguments\n\npath::AbstractString = folder path\ndirectory::AbstractString = \"2019-10-03T09-18-00\": the foulder name that contains\n\nfeather files of the results.\n\nExample\n\nresults = load_operation_results(\"/Users/test/2019-10-03T09-18-00\")\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.load_simulation_results-Tuple{SimulationResultsReference,String}","page":"PowerSimulations","title":"PowerSimulations.load_simulation_results","text":"load_simulation_results(sim_output, stage)\n\nThis function goes through the reference table of file paths and aggregates the results over time into a struct of type OperationsProblemResults\n\nArguments\n\nsim_output::SimulationResultsReference: the container for the reference dictionary created in execute!\nstage_number::String: The stage of the results getting parsed\n\nExample\n\nsim_output = execute!(simulation)\nresults = load_simulation_results(sim_output, \"stage_name\")\n\nAccepted Key Words\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.load_simulation_results-Tuple{String,String,Vararg{Any,N} where N}","page":"PowerSimulations","title":"PowerSimulations.load_simulation_results","text":"load_simulation_results(file_path, stage)\n\nThis function goes through the reference table of file paths and aggregates the results over time into a struct of type OperationsProblemResults\n\nArguments\n\nfile_path::String: the file path to the dated folder with the raw results\nstage_number::String: The stage of the results getting parsed\n\nExample\n\nexecute!(simulation)\nresults = load_simulation_results(\"file_path\", \"stage_name\")\n\nAccepted Key Words\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.make_references-Tuple{Simulation,String}","page":"PowerSimulations","title":"PowerSimulations.make_references","text":"make_references(sim::Simulation, date_run::String; kwargs...)\n\nCreates a dictionary of variables with a dictionary of stages that contains dataframes of date/step/and desired file path so that the results can be parsed sequentially by variable and stage type.\n\nNote: makereferences can only be run after runsim_model or else, the folder structure will not yet be populated with results\n\nArguments\n\nsim::Simulation = sim: simulation object created by Simulation()\ndate_run::String = \"2019-10-03T09-18-00\"`: the name of the file created\n\nthat contains the specific simulation run of the date run and \"-test\"\n\nExample\n\nsim = Simulation(\"Test\", 7, stages, \"/Users/yourusername/Desktop/\"; system_to_file = false)\nexecute!(sim::Simulation; kwargs...)\nreferences = make_references(sim, \"2019-10-03T09-18-00-test\")\n\nAccepted Key Words\n\nconstraints_duals::Vector{Symbol}: name of dual constraints to be added to results\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.solve_op_problem!-Union{Tuple{OperationsProblem{T}}, Tuple{T}} where T<:PowerSimulations.AbstractOperationsProblem","page":"PowerSimulations","title":"PowerSimulations.solve_op_problem!","text":"solve_op_problem!(op_problem::OperationsProblem; kwargs...)\n\nThis solves the operational model for a single instance and outputs results of type OperationsProblemResult\n\nArguments\n\nop_problem::OperationModel = op_problem: operation model\n\nExamples\n\nresults = solve_op_problem!(OpModel)\n\nAccepted Key Words\n\nsave_path::String: If a file path is provided the results\n\nautomatically get written to feather files\n\noptimizer::MOI.OptimizerWithAttributes: The optimizer that is used to solve the model\nconstraints_duals::Array: Array of the constraints duals to be in the results\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.template_economic_dispatch-Tuple{}","page":"PowerSimulations","title":"PowerSimulations.template_economic_dispatch","text":"template_economic_dispatch(; kwargs...)\n\nCreates an OperationsProblemTemplate with default DeviceModels for an Economic Dispatch problem.\n\nExample\n\ntemplate = template_economic_dispatch()\n\nAccepted Key Words\n\nnetwork::Type{<:PM.AbstractPowerModel} : override default network model settings\ndevices::Dict{Symbol, DeviceModel} : override default DeviceModel settings\nbranches::Dict{Symbol, DeviceModel} : override default DeviceModel settings\nservices::Dict{Symbol, ServiceModel} : override default ServiceModel settings\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.template_unit_commitment-Tuple{}","page":"PowerSimulations","title":"PowerSimulations.template_unit_commitment","text":"template_unit_commitment(; kwargs...)\n\nCreates an OperationsProblemTemplate with default DeviceModels for a Unit Commitment problem.\n\nExample\n\ntemplate = template_unit_commitment()\n\nAccepted Key Words\n\nnetwork::Type{<:PM.AbstractPowerModel} : override default network model settings\ndevices::Dict{Symbol, DeviceModel} : override default DeviceModel settings\nbranches::Dict{Symbol, DeviceModel} : override default DeviceModel settings\nservices::Dict{Symbol, ServiceModel} : override default ServiceModel settings\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.write_op_problem-Tuple{OperationsProblem,String}","page":"PowerSimulations","title":"PowerSimulations.write_op_problem","text":"Exports the OpModel JuMP object in MathOptFormat\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#Internal-1","page":"PowerSimulations","title":"Internal","text":"","category":"section"},{"location":"api/PowerSimulations.html#","page":"PowerSimulations","title":"PowerSimulations","text":"Modules = [PowerSimulations]\nPublic = false","category":"page"},{"location":"api/PowerSimulations.html#PowerSimulations.DeviceRange","page":"PowerSimulations","title":"PowerSimulations.DeviceRange","text":"Data Container to construct range constraints\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations.html#PowerSimulations.UpdateRef","page":"PowerSimulations","title":"PowerSimulations.UpdateRef","text":"Reference for parameters update when present\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations.html#Base.show-Tuple{IO,MIME{Symbol(\"text/plain\")},OperationsProblem}","page":"PowerSimulations","title":"Base.show","text":"Base.show(io::IO, ::MIME\"text/plain\", op_problem::OperationsProblem)\n\nThis function goes through the fields in OperationsProblem and then in OperationsProblemTemplate, if the field contains a Device model dictionary, it calls organizedevicemodel() & prints the data by field, key, value. If the field is not a Device model dictionary, and a value exists for that field it prints the value.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations._allocate_execution_order-Tuple{Dict{Int64,Int64}}","page":"PowerSimulations","title":"PowerSimulations._allocate_execution_order","text":"Function calculates the total number of stage executions in the simulation and allocates the appropiate vector\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations._calculate_interval_inner_counts-Tuple{Dict{Int64,String},Dict{String,Tuple{Dates.TimePeriod,#s24} where #s24<:PowerSimulations.FeedForwardChronology},Dates.TimePeriod}","page":"PowerSimulations","title":"PowerSimulations._calculate_interval_inner_counts","text":"_calculate_interval_inner_counts(order::Dict{Int,String},\n                                      intervals::Dict{String,<:Dates.TimePeriod},\n                                      step_resolution::Dates.TimePeriod)\n\nCalculates how many times a stage is executed for every interval of the previous stage\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations._get_data_for_rocc-Tuple{Array{InitialCondition,1},Dates.TimePeriod}","page":"PowerSimulations","title":"PowerSimulations._get_data_for_rocc","text":"This function gets the data for the generators\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations._get_data_for_tdc-Tuple{Array{InitialCondition,1},Array{InitialCondition,1},Dates.TimePeriod}","page":"PowerSimulations","title":"PowerSimulations._get_data_for_tdc","text":"If the fraction of hours that a generator has a duration constraint is less than the fraction of hours that a single time_step represents then it is not binding.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations._pwl_cost-Union{Tuple{JV}, Tuple{PowerSimulations.PSIContainer,JV,Array{Tuple{Float64,Float64},1}}} where JV<:JuMP.AbstractVariableRef","page":"PowerSimulations","title":"PowerSimulations._pwl_cost","text":"_gen_cost(cost_)\n\nReturns JuMP expression for a piecewise linear cost function depending on the data compatibility.\n\nReturns gen_cost\n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\nvariable::JuMP.Containers.DenseAxisArray{JV} : variable array\ncost_component::PSY.VariableCost{NTuple{2, Float64}} : container for quadratic and linear factors\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations._pwlgencost_linear-Union{Tuple{JV}, Tuple{PowerSimulations.PSIContainer,JV,Array{Tuple{Float64,Float64},1}}} where JV<:JuMP.AbstractVariableRef","page":"PowerSimulations","title":"PowerSimulations._pwlgencost_linear","text":"_pwlgencost_sos(psi_container::PSIContainer,\n            variable::JuMP.Containers.DenseAxisArray{JV},\n            cost_component::PSY.VariableCost{NTuple{2, Float64}}) where {JV <: JuMP.AbstractVariableRef}\n\nReturns piecewise cost expression using linear implementation for psi_container model.\n\nEquations\n\n0 <= pwl_var[i] <= (cost_component[2][i] - cost_component[2][i-1])\n\nvariable = sum(pwl_var[i])\n\ngen_cost = sum(pwl_var[i]*cost_component[1][i]/cost_component[2][i])\n\nLaTeX\n\n0 = pwl_i = (c_2 i - c_2 i-1)\n\nvariable = (sum_iin I pwl_i)\n\ngen_cost = (sum_iin I  pwl_i) c_1 ic_2 i\n\nReturns gen_cost\n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\nvariable::JuMP.Containers.DenseAxisArray{JV} : variable array\ncost_component::PSY.VariableCost{NTuple{2, Float64}} : container for quadratic and linear factors\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations._pwlgencost_sos-Union{Tuple{JV}, Tuple{PowerSimulations.PSIContainer,JV,Array{Tuple{Float64,Float64},1}}} where JV<:JuMP.AbstractVariableRef","page":"PowerSimulations","title":"PowerSimulations._pwlgencost_sos","text":"_pwlgencost_sos(psi_container::PSIContainer,\n            variable::JuMP.Containers.DenseAxisArray{JV},\n            cost_component::PSY.VariableCost{NTuple{2, Float64}}) where {JV <: JuMP.AbstractVariableRef}\n\nReturns piecewise cost expression using SOS Type-2 implementation for psi_container model.\n\nEquations\n\nvariable = sum(sos_var[i]*cost_component[2][i])\n\ngen_cost = sum(sos_var[i]*cost_component[1][i])\n\nLaTeX\n\nvariable = (sum_iin I c_2 i sos_i)\n\ngen_cost = (sum_iin I c_1 i sos_i)\n\nReturns gen_cost\n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\nvariable::JuMP.Containers.DenseAxisArray{JV} : variable array\ncost_component::PSY.VariableCost{NTuple{2, Float64}} : container for quadratic and linear factors\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations._pwlparamcheck-Tuple{Any}","page":"PowerSimulations","title":"PowerSimulations._pwlparamcheck","text":"_pwlparamcheck(cost_)\n\nReturns True/False depending on compatibility of the cost data with the linear implementation method\n\nReturns flag\n\nArguments\n\ncost_::PSY.VariableCost{NTuple{2, Float64}} : container for quadratic and linear factors\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations._update_stage!-Tuple{Stage,Simulation}","page":"PowerSimulations","title":"PowerSimulations._update_stage!","text":"Required update stage function call\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations._write_psi_container-Tuple{PowerSimulations.PSIContainer,String}","page":"PowerSimulations","title":"PowerSimulations._write_psi_container","text":"Exports the OpModel JuMP object in MathOptFormat\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.activepower_constraints!-Union{Tuple{T}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{T},DeviceModel{T,#s420} where #s420<:PowerSimulations.AbstractThermalDispatchFormulation,Type{#s419} where #s419<:PowerModels.AbstractPowerModel,Nothing}} where T<:PowerSystems.ThermalGen","page":"PowerSimulations","title":"PowerSimulations.activepower_constraints!","text":"This function adds the active power limits of generators when there are no CommitmentVariables\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.activepower_constraints!-Union{Tuple{T}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{T},DeviceModel{T,#s420} where #s420<:PowerSimulations.AbstractThermalFormulation,Type{#s419} where #s419<:PowerModels.AbstractPowerModel,Nothing}} where T<:PowerSystems.ThermalGen","page":"PowerSimulations","title":"PowerSimulations.activepower_constraints!","text":"This function adds the active power limits of generators when there are CommitmentVariables\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.activepower_constraints!-Union{Tuple{T}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{T},DeviceModel{T,ThermalDispatchNoMin},Type{#s420} where #s420<:PowerModels.AbstractPowerModel,Nothing}} where T<:PowerSystems.ThermalGen","page":"PowerSimulations","title":"PowerSimulations.activepower_constraints!","text":"This function adds the active power limits of generators when there are     no CommitmentVariables\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.activepower_variables!-Union{Tuple{T}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{T}}} where T<:PowerSystems.ThermalGen","page":"PowerSimulations","title":"PowerSimulations.activepower_variables!","text":"This function add the variables for power generation output to the model\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.activeservice_variables!-Union{Tuple{SR}, Tuple{PowerSimulations.PSIContainer,SR,Array{#s422,1} where #s422<:PowerSystems.Device}} where SR<:PowerSystems.Reserve","page":"PowerSimulations","title":"PowerSimulations.activeservice_variables!","text":"This function add the variables for reserves to the model\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.add_to_cost-Union{Tuple{D}, Tuple{PowerSimulations.PSIContainer,D,Symbol,Symbol}, Tuple{PowerSimulations.PSIContainer,D,Symbol,Symbol,Float64}} where D<:(InfrastructureSystems.FlattenIteratorWrapper{#s420} where #s420<:PowerSystems.Device)","page":"PowerSimulations","title":"PowerSimulations.add_to_cost","text":"add_to_cost(psi_container::PSIContainer,\n                 devices::D,\n                 var_name::Symbol,\n                 cost_symbol::Symbol,\n                 sign::Float64 = 1.0) where {D<:IS.FlattenIteratorWrapper{<:PSY.Device}}\n\nAdds cost expression for each device using appropriate call to ps_cost.\n\nExpression\n\nfor d in devices\n\n                              variable[PSY.get_name(d), :],\n                              getfield(PSY.get_op_cost(d), cost_symbol),\n                              dt,\n                              sign) ```\n\npsicontainer.costfunction += cost_expression ```\n\nLaTeX\n\nCOST = sum_din D cost_d\n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\ndevices::D : set of devices\nvar_name::Symbol : name of variable\ncost_symbol::Symbol : symbol associated with costx\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.add_variable-Union{Tuple{D}, Tuple{PowerSimulations.PSIContainer,D,Symbol,Bool}, Tuple{PowerSimulations.PSIContainer,D,Symbol,Bool,Union{Nothing, Symbol}}, Tuple{PowerSimulations.PSIContainer,D,Symbol,Bool,Union{Nothing, Symbol},Float64}} where D<:Union{Array{#s24,1} where #s24<:PowerSystems.Device, InfrastructureSystems.FlattenIteratorWrapper{#s23} where #s23<:PowerSystems.Device}","page":"PowerSimulations","title":"PowerSimulations.add_variable","text":"add_variable(psi_container::PSIContainer,\n                  devices::D,\n                  var_name::Symbol,\n                  binary::Bool,\n                  expression_name::Symbol,\n                  sign::Float64)\n\nAdds a variable to the optimization model and to the affine expressions contained in the psi_container model according to the specified sign. Based on the inputs, the variable can be specified as binary.\n\nBounds\n\nlb_value_function <= varstart[name, t] <= ub_value_function\n\nIf binary = true:\n\nvarstart[name, t] in {0,1}\n\nLaTeX\n\nlb ge x^device_t le ub forall t\n\nx^device_t in 01 forall t iff textbinary = true\n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\ndevices : Vector or Iterator with the devices\nvar_name::Symbol : Base Name for the variable\nbinary::Bool : Select if the variable is binary\nexpressionname::Symbol : Expressionname name stored in psi_container.expressions to add the variable\nsign::Float64 : sign of the addition of the variable to the expression_name. Default Value is 1.0\n\nAccepted Keyword Arguments\n\nubvaluefunction : Provides the function over device to obtain the value for a upper_bound\nlbvaluefunction : Provides the function over device to obtain the value for a lower_bound. If the variable is meant to be positive define lb = x -> 0.0\ninitialvaluefunction : Provides the function over device to obtain the warm start value\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.build_nip-Tuple{PowerModels.AbstractPowerModel}","page":"PowerSimulations","title":"PowerSimulations.build_nip","text":"\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.commitment_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{T},DeviceModel{T,D},Type{S},Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where S<:PowerModels.AbstractPowerModel where D<:PowerSimulations.AbstractThermalFormulation where T<:PowerSystems.ThermalGen","page":"PowerSimulations","title":"PowerSimulations.commitment_constraints!","text":"This function adds the Commitment Status constraint when there are CommitmentVariables\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.commitment_variables!-Union{Tuple{H}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{H}}} where H<:PowerSystems.HydroGen","page":"PowerSimulations","title":"PowerSimulations.commitment_variables!","text":"This function add the variables for power generation commitment to the model\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.commitment_variables!-Union{Tuple{T}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{T}}} where T<:PowerSystems.ThermalGen","page":"PowerSimulations","title":"PowerSimulations.commitment_variables!","text":"This function add the variables for power generation commitment to the model\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.compute_sha256-Tuple{AbstractString}","page":"PowerSimulations","title":"PowerSimulations.compute_sha256","text":"Return the SHA 256 hash of a file.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.constraint_power_balance_ni-Tuple{PowerModels.AbstractActivePowerModel,Int64,Int64,Any,Any}","page":"PowerSimulations","title":"PowerSimulations.constraint_power_balance_ni","text":"active power only models ignore reactive power flows\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.constraint_power_balance_ni-Tuple{PowerModels.AbstractPowerModel,Int64,Int64,Any,Any}","page":"PowerSimulations","title":"PowerSimulations.constraint_power_balance_ni","text":"\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.constraint_power_balance_ni-Tuple{PowerModels.AbstractPowerModel,Int64}","page":"PowerSimulations","title":"PowerSimulations.constraint_power_balance_ni","text":"\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.constraint_power_balance_ni_expr-Tuple{PowerModels.AbstractActivePowerModel,Int64,Int64,Any,Any,Any,Any}","page":"PowerSimulations","title":"PowerSimulations.constraint_power_balance_ni_expr","text":"\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.constraint_power_balance_ni_expr-Tuple{PowerModels.AbstractPowerModel,Int64,Int64,Any,Any,Any,Any}","page":"PowerSimulations","title":"PowerSimulations.constraint_power_balance_ni_expr","text":"\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.constraint_power_balance_ni_expr-Tuple{PowerModels.AbstractPowerModel,Int64}","page":"PowerSimulations","title":"PowerSimulations.constraint_power_balance_ni_expr","text":"\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.container_spec-Union{Tuple{M}, Tuple{M,Vararg{Any,N} where N}} where M<:JuMP.AbstractModel","page":"PowerSimulations","title":"PowerSimulations.container_spec","text":"Returns the correct container spec for the selected type of JuMP Model\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.device_commitment-Tuple{PowerSimulations.PSIContainer,Array{InitialCondition,1},Symbol,Tuple{Symbol,Symbol,Symbol}}","page":"PowerSimulations","title":"PowerSimulations.device_commitment","text":"device_commitment(psi_container::PSIContainer,\n                    initial_conditions::Vector{InitialCondition},\n                    cons_name::Symbol,\n                    var_names::Tuple{Symbol, Symbol, Symbol})\n\nConstructs multi-timestep constraint from initial conditions and binary variable tuple.\n\nConstraints\n\nvarstart + varstop <= 1.0\n\nIf t = 1:\n\nvaron[name, 1] == ic.value + varstart[name, 1] - varstop[name, 1]\n\nwhere ic in initial_condtions.\n\nIf t > 1:\n\nvaron[name, t] == varon[name, t-1] + varstart[name, t] - varstop[name, t]\n\nLaTeX\n\nx^on_t + x^off_t leq 10 forall t\n\nx^on_1 = x^on_init + x^start_1 - x^stop_1 text for  t = 1\n\nx^on_t = x^on_t-1 + x^start_t - x^stop_t forall t geq 2\n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\ninitial_conditions::Vector{InitialCondition} : for time zero 'varon'\ncons_name::Symbol : name of the constraint\nvar_names::Tuple{Symbol, Symbol, Symbol} : the names of the variables\n: var_names[1] : varstart\n: var_names[2] : varstop\n: var_names[3] : varon\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.device_duration_look_ahead-Tuple{PowerSimulations.PSIContainer,Array{NamedTuple{(:up, :down),Tuple{Float64,Float64}},1},Array{InitialCondition,2},Symbol,Tuple{Symbol,Symbol,Symbol}}","page":"PowerSimulations","title":"PowerSimulations.device_duration_look_ahead","text":"device_duration_look_ahead(psi_container::PSIContainer,\n                            duration_data::Vector{UpDown},\n                            initial_duration::Matrix{InitialCondition},\n                            cons_name::Symbol,\n                            var_names::Tuple{Symbol, Symbol, Symbol})\n\nThis formulation of the duration constraints looks ahead in the time frame of the model.\n\nLaTeX\n\nMinimum up-time constraint:\n\nIf t leq d_min^up\n\nd_min^downx_t^stop - sum_i=t-d_min^up + 1^t x_i^on - x_init^up leq 0\n\nfor i in the set of time steps. Otherwise:\n\nd_min^downx_t^stop - sum_i=t-d_min^up + 1^t x_i^on leq 0\n\nfor i in the set of time steps.\n\nMinimum down-time constraint:\n\nIf t leq d_min^down\n\nd_min^upx_t^start - sum_i=t-d_min^down + 1^t (1 - x_i^on) - x_init^down leq 0\n\nfor i in the set of time steps. Otherwise:\n\nd_min^upx_t^start - sum_i=t-d_min^down + 1^t (1 - x_i^on) leq 0\n\nfor i in the set of time steps.\n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\nduration_data::Vector{UpDown} : gives how many time steps variable needs to be up or down\ninitial_duration::Matrix{InitialCondition} : gives initial conditions for up (column 1) and down (column 2)\ncons_name::Symbol : name of the constraint\nvar_names::Tuple{Symbol, Symbol, Symbol}) : names of the variables\n: var_names[1] : varon\n: var_names[2] : varstart\n: var_names[3] : varstop\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.device_duration_parameters-Tuple{PowerSimulations.PSIContainer,Array{NamedTuple{(:up, :down),Tuple{Float64,Float64}},1},Array{InitialCondition,2},Symbol,Tuple{Symbol,Symbol,Symbol}}","page":"PowerSimulations","title":"PowerSimulations.device_duration_parameters","text":"device_duration_parameters(psi_container::PSIContainer,\n                         duration_data::Vector{UpDown},\n                         initial_duration_on::Vector{InitialCondition},\n                         initial_duration_off::Vector{InitialCondition},\n                         cons_name::Symbol,\n                         var_names::Tuple{Symbol, Symbol, Symbol})\n\nThis formulation of the duration constraints considers parameters.\n\nLaTeX\n\nMinimum up-time constraint:\n\nIf t leq d_min^up\n\nd_min^downx_t^stop - sum_i=t-d_min^up + 1^t x_i^on - x_init^up leq 0\n\nfor i in the set of time steps. Otherwise:\n\nsum_i=t-d_min^up + 1^t x_i^start - x_t^on leq 0\n\nfor i in the set of time steps.\n\nMinimum down-time constraint:\n\nIf t leq d_min^down\n\nd_min^upx_t^start - sum_i=t-d_min^down + 1^t (1 - x_i^on) - x_init^down leq 0\n\nfor i in the set of time steps. Otherwise:\n\nsum_i=t-d_min^down + 1^t x_i^stop + x_t^on leq 1\n\nfor i in the set of time steps.\n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\nduration_data::Vector{UpDown} : gives how many time steps variable needs to be up or down\ninitialdurationon::Vector{InitialCondition} : gives initial number of time steps variable is up\ninitialdurationoff::Vector{InitialCondition} : gives initial number of time steps variable is down\ncons_name::Symbol : name of the constraint\nvar_names::Tuple{Symbol, Symbol, Symbol}) : names of the variables\n: var_names[1] : varon\n: var_names[2] : varstart\n: var_names[3] : varstop\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.device_duration_retrospective-Tuple{PowerSimulations.PSIContainer,Array{NamedTuple{(:up, :down),Tuple{Float64,Float64}},1},Array{InitialCondition,2},Symbol,Tuple{Symbol,Symbol,Symbol}}","page":"PowerSimulations","title":"PowerSimulations.device_duration_retrospective","text":"device_duration_retrospective(psi_container::PSIContainer,\n                                    duration_data::Vector{UpDown},\n                                    initial_duration::Matrix{InitialCondition},\n                                    cons_name::Symbol,\n                                    var_names::Tuple{Symbol, Symbol, Symbol})\n\nThis formulation of the duration constraints adds over the start times looking backwards.\n\nLaTeX\n\nMinimum up-time constraint:\n\nIf t leq d_min^up - d_init^up and d_init^up  0\n\n1 + sum_i=t-d_min^up + 1^t x_i^start - x_t^on leq 0\n\nfor i in the set of time steps. Otherwise:\n\nsum_i=t-d_min^up + 1^t x_i^start - x_t^on leq 0\n\nfor i in the set of time steps.\n\nMinimum down-time constraint:\n\nIf t leq d_min^down - d_init^down and d_init^down  0\n\n1 + sum_i=t-d_min^down + 1^t x_i^stop + x_t^on leq 1\n\nfor i in the set of time steps. Otherwise:\n\nsum_i=t-d_min^down + 1^t x_i^stop + x_t^on leq 1\n\nfor i in the set of time steps.\n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\nduration_data::Vector{UpDown} : gives how many time steps variable needs to be up or down\ninitial_duration::Matrix{InitialCondition} : gives initial conditions for up (column 1) and down (column 2)\ncons_name::Symbol : name of the constraint\nvar_names::Tuple{Symbol, Symbol, Symbol}) : names of the variables\n: var_names[1] : varon\n: var_names[2] : varstart\n: var_names[3] : varstop\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.device_linear_rateofchange-Tuple{PowerSimulations.PSIContainer,Array{NamedTuple{(:up, :down),Tuple{Float64,Float64}},1},Array{InitialCondition,1},Symbol,Symbol}","page":"PowerSimulations","title":"PowerSimulations.device_linear_rateofchange","text":"device_linear_rateofchange(psi_container::PSIContainer,\n                                rate_data::Tuple{Vector{String}, Vector{UpDown}},\n                                initial_conditions::Vector{InitialCondition},\n                                cons_name::Symbol,\n                                var_name::Symbol)\n\nConstructs allowed rate-of-change constraints from variables, initial condtions, and rate data.\n\nConstraints\n\nIf t = 1:\n\nvariable[name, 1] - initial_conditions[ix].value <= rate_data[1][ix].up\n\ninitial_conditions[ix].value - variable[name, 1] <= rate_data[1][ix].down\n\nIf t > 1:\n\nvariable[name, t] - variable[name, t-1] <= rate_data[1][ix].up\n\nvariable[name, t-1] - variable[name, t] <= rate_data[1][ix].down\n\nLaTeX\n\nr^down leq x_1 - x_init leq r^up text for  t = 1\n\nr^down leq x_t - x_t-1 leq r^up forall t geq 2\n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\nrate_data::Tuple{Vector{String}, Vector{UpDown}} : gives name (1) and max ramp up/down rates (2)\ninitial_conditions::Vector{InitialCondition} : for time zero 'variable'\ncons_name::Symbol : name of the constraint\nvar_name::Tuple{Symbol, Symbol, Symbol} : the name of the variable\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.device_mixedinteger_rateofchange-Tuple{PowerSimulations.PSIContainer,Tuple{Array{NamedTuple{(:up, :down),Tuple{Float64,Float64}},1},Array{NamedTuple{(:min, :max),Tuple{Float64,Float64}},1}},Array{InitialCondition,1},Symbol,Tuple{Symbol,Symbol,Symbol}}","page":"PowerSimulations","title":"PowerSimulations.device_mixedinteger_rateofchange","text":"device_mixedinteger_rateofchange(psi_container::PSIContainer,\n                                      rate_data::Tuple{Vector{String}, Vector{UpDown}, Vector{MinMax}},\n                                      initial_conditions::Vector{InitialCondition},\n                                      cons_name::Symbol,\n                                      var_names::Tuple{Symbol, Symbol, Symbol})\n\nConstructs allowed rate-of-change constraints from variables, initial condtions, start/stop status, and rate data\n\nEquations\n\nIf t = 1:\n\nvariable[name, 1] - initial_conditions[ix].value <= rate_data[1][ix].up + rate_data[2][ix].max*varstart[name, 1]\n\ninitial_conditions[ix].value - variable[name, 1] <= rate_data[1][ix].down + rate_data[2][ix].min*varstop[name, 1]\n\nIf t > 1:\n\nvariable[name, t] - variable[name, t-1] <= rate_data[1][ix].up + rate_data[2][ix].max*varstart[name, t]\n\nvariable[name, t-1] - variable[name, t] <= rate_data[1][ix].down + rate_data[2][ix].min*varstop[name, t]\n\nLaTeX\n\nr^down + r^min x^stop_1 leq x_1 - x_init leq r^up + r^max x^start_1 text for  t = 1\n\nr^down + r^min x^stop_t leq x_t - x_t-1 leq r^up + r^max x^start_t forall t geq 2\n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\nrate_data::Tuple{Vector{String}, Vector{UpDown}, Vector{MinMax}} : (1) gives name                                                                    (2) gives min/max ramp rates                                                                    (3) gives min/max for 'variable'\ninitial_conditions::Vector{InitialCondition} : for time zero 'variable'\ncons_name::Symbol : name of the constraint\nvar_names::Tuple{Symbol, Symbol, Symbol} : the names of the variables\n: var_names[1] : 'variable'\n: var_names[2] : 'varstart'\n: var_names[3] : 'varstop'\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.device_range-Tuple{PowerSimulations.PSIContainer,Array{PowerSimulations.DeviceRange,1},Symbol,Symbol}","page":"PowerSimulations","title":"PowerSimulations.device_range","text":"device_range(psi_container::PSIContainer,\n             range_data::Vector{DeviceRange},\n             cons_name::Symbol,\n             var_name::Symbol)\n\nConstructs min/max range constraint from device variable.\n\nConstraints\n\nIf min and max within an epsilon width:\n\nvariable[name, t] == limits.max\n\nOtherwise:\n\nlimits.min <= variable[name, t] <= limits.max\n\nwhere limits in range_data.\n\nLaTeX\n\nx = limits^max text for  limits^max - limits^min  varepsilon\n\nlimits^min leq x leq limits^max text otherwise \n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\nrange_data::Vector{DeviceRange} : contains names and vector of min/max\ncons_name::Symbol : name of the constraint\nvar_name::Symbol : the name of the continuous variable\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.device_semicontinuousrange-Tuple{PowerSimulations.PSIContainer,Array{PowerSimulations.DeviceRange,1},Symbol,Symbol,Symbol}","page":"PowerSimulations","title":"PowerSimulations.device_semicontinuousrange","text":"device_semicontinuousrange(psi_container::PSIContainer,\n                                range_data::Vector{DeviceRange},\n                                cons_name::Symbol,\n                                var_name::Symbol,\n                                binvar_name::Symbol)\n\nConstructs min/max range constraint from device variable and on/off decision variable.\n\nConstraints\n\nIf device min = 0:\n\nvarcts[name, t] <= limits.max*varbin[name, t])\n\nvarcts[name, t] >= 0.0\n\nOtherwise:\n\nvarcts[name, t] <= limits.max*varbin[name, t]\n\nvarcts[name, t] >= limits.min*varbin[name, t]\n\nwhere limits in range_data.\n\nLaTeX\n\n0 leq x^cts leq limits^max x^bin text for  limits^min = 0\n\nlimits^min x^bin leq x^cts leq limits^max x^bin text otherwise \n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\nrange_data::Vector{DeviceRange} : contains names and vector of min/max\ncons_name::Symbol : name of the constraint\nvar_name::Symbol : the name of the continuous variable\nbinvar_name::Symbol : the name of the binary variable\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.device_timeseries_lb-Tuple{PowerSimulations.PSIContainer,Array{PowerSimulations.DeviceTimeSeries,1},Symbol,Symbol}","page":"PowerSimulations","title":"PowerSimulations.device_timeseries_lb","text":"device_timeseries_lb(psi_container::PSIContainer,\n                 ts_data::Vector{DeviceTimeSeries},\n                 cons_name::Symbol,\n                 var_name::Symbol)\n\nConstructs lower bound for given variable subject to time series data and a multiplier.\n\nConstraint\n\nts_data[name].multiplier * ts_data[name].timeseries[t] <= variable[name, t]\n\nLaTeX\n\nr^val r_t leq x_t forall t\n\nwhere (name, data) in range_data.\n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\nts_data::Vector{DeviceTimeSeries} : container of device time series data and scaling factors\ncons_name::Symbol : name of the constraint\nvar_name::Symbol : the name of the variable\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.device_timeseries_param_lb-Tuple{PowerSimulations.PSIContainer,Array{PowerSimulations.DeviceTimeSeries,1},Symbol,PowerSimulations.UpdateRef,Symbol}","page":"PowerSimulations","title":"PowerSimulations.device_timeseries_param_lb","text":"device_timeseries_param_lb(psi_container::PSIContainer,\n                                ts_data::Vector{DeviceTimeSeries},\n                                cons_name::Symbol,\n                                param_reference::UpdateRef,\n                                var_name::Symbol)\n\nConstructs lower bound for given variable using a parameter. The constraint is     built with a time series data vector and a multiplier\n\nConstraint\n\nts_data[name].multiplier * param[name, t] <= variable[name, t]\n\nLaTeX\n\nr^val x^param_t leq x^var_t forall t\n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\nts_data::Vector{DeviceTimeSeries} : container of device time series data and scaling factors\ncons_name::Symbol : name of the constraint\nparam_reference::UpdateRef : UpdateRef to access the parameter\nvar_name::Symbol : the name of the variable\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.device_timeseries_param_ub-Tuple{PowerSimulations.PSIContainer,Array{PowerSimulations.DeviceTimeSeries,1},Symbol,PowerSimulations.UpdateRef,Symbol}","page":"PowerSimulations","title":"PowerSimulations.device_timeseries_param_ub","text":"device_timeseries_param_ub(psi_container::PSIContainer,\n                                ts_data::Vector{DeviceTimeSeries},\n                                cons_name::Symbol,\n                                param_reference::UpdateRef,\n                                var_name::Symbol)\n\nConstructs upper bound for given variable using a parameter. The constraint is     built with a time series data vector and a multiplier\n\nConstraint\n\nvariable[name, t] <= ts_data[name].multiplier * param[name, t]\n\nLaTeX\n\nx^var_t leq r^val x^param_t forall t\n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\nts_data::Vector{DeviceTimeSeries} : container of device time series data and scaling factors\ncons_name::Symbol : name of the constraint\nparam_reference::UpdateRef : UpdateRef to access the parameter\nvar_name::Symbol : the name of the variable\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.device_timeseries_ub-Tuple{PowerSimulations.PSIContainer,Array{PowerSimulations.DeviceTimeSeries,1},Symbol,Symbol}","page":"PowerSimulations","title":"PowerSimulations.device_timeseries_ub","text":"device_timeseries_ub(psi_container::PSIContainer,\n                 ts_data::Vector{DeviceTimeSeries},\n                 cons_name::Symbol,\n                 var_name::Symbol)\n\nConstructs upper bound for given variable and time series data and a multiplier.\n\nConstraint\n\nvariable[name, t] <= ts_data[name].multiplier * ts_data[name].timeseries[t]\n\nLaTeX\n\nx_t leq r^val r_t forall t\n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\nts_data::Vector{DeviceTimeSeries} : container of device time series data and scaling factors\ncons_name::Symbol : name of the constraint\nvar_name::Symbol : the name of the variable\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.device_timeseries_ub_bigM","page":"PowerSimulations","title":"PowerSimulations.device_timeseries_ub_bigM","text":"device_timeseries_ub_bigM(psi_container::PSIContainer,\n                                ts_data::Vector{DeviceTimeSeries},\n                                cons_name::Symbol,\n                                var_name::Symbol,\n                                param_reference::UpdateRef,\n                                binvar_name::Symbol,\n                                M_value::Float64 = 1e6)\n\nConstructs upper bound for variable and time series and a multiplier or confines to 0 depending on binary variable.     Uses BigM constraint type to allow for parameter since ParameterJuMP doesn't support var*parameter\n\nConstraints\n\nvarcts[name, t] - ts_data[name].multipliers * param[name, t] <= (1 - varbin[name, t]) * M_value\n\nvarcts[name, t] <= varbin[name, t]*M_value\n\nLaTeX\n\nx^cts_t - r^val x^param_t leq M(1 - x^bin_t ) forall t\n\nx^cts_t leq M x^bin_t forall t\n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\nts_data::Vector{DeviceTimeSeries} : container of device time series data and scaling factors\ncons_name::Symbol : name of the constraint\nvar_name::Symbol :  name of the variable\n\nparam_reference::UpdateRef : UpdateRef of access the parameters\n\nbinvar_name::Symbol : name of binary variable\nM_value::Float64 : bigM\n\n\n\n\n\n","category":"function"},{"location":"api/PowerSimulations.html#PowerSimulations.device_timeseries_ub_bin-Tuple{PowerSimulations.PSIContainer,Array{PowerSimulations.DeviceTimeSeries,1},Symbol,Symbol,Symbol}","page":"PowerSimulations","title":"PowerSimulations.device_timeseries_ub_bin","text":"device_timeseries_ub_bin(psi_container::PSIContainer,\n                                ts_data::Vector{DeviceTimeSeries},\n                                var_name::Symbol,\n                                binvar_name::Symbol)\n\nConstructs upper bound for variable and time series or confines to 0 depending on binary variable.     The upper bound is defined by a time series and a multiplier.\n\nConstraints\n\nvarcts[name, t] <= varbin[name, t]* ts_data[name].multiplier * ts_data[name].timeseries[t]\n\nwhere (name, data) in range_data.\n\nLaTeX\n\nx^cts_t leq r^val r_t x^bin_t forall t\n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\nts_data::Vector{DeviceTimeSeries} : container of device time series data and scaling factors\ncons_name::Symbol : name of the constraint\nvar_name::Symbol :  name of the variable\nbinvar_name::Symbol : name of binary variable\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.energy_balance-Tuple{PowerSimulations.PSIContainer,Array{InitialCondition,1},Tuple{Array{String,1},Array{NamedTuple{(:in, :out),Tuple{Float64,Float64}},1}},Symbol,Tuple{Symbol,Symbol,Symbol}}","page":"PowerSimulations","title":"PowerSimulations.energy_balance","text":"energy_balance(psi_container::PSIContainer,\n                    initial_conditions::Vector{InitialCondition},\n                    efficiency_data::Tuple{Vector{String}, Vector{InOut}},\n                    cons_name::Symbol,\n                    var_names::Tuple{Symbol, Symbol, Symbol})\n\nConstructs multi-timestep constraint from initial condition, efficiency data, and variable tuple\n\nConstraints\n\nIf t = 1:\n\nvarenergy[name, 1] == initial_conditions[ix].value + varin[name, 1]*eff_in*fraction_of_hour - varout[name, 1]*fraction_of_hour/eff_out\n\nIf t > 1:\n\nvarenergy[name, t] == varenergy[name, t-1] + varin[name, t]*eff_in*fraction_of_hour - varout[name, t]*fraction_of_hour/eff_out\n\nLaTeX\n\nx^energy_1 == x^energy_init + frhr eta^in x^in_1 - fracfrhreta^out x^out_1 text for  t = 1\n\nx^energy_t == x^energy_t-1 + frhr eta^in x^in_t - fracfrhreta^out x^out_t forall t geq 2\n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\ninitial_conditions::Vector{InitialCondition} : for time zero 'varenergy'\nefficiency_data::Tuple{Vector{String}, Vector{InOut}} :: charging/discharging efficiencies\ncons_name::Symbol : name of the constraint\nvar_names::Tuple{Symbol, Symbol, Symbol} : the names of the variables\n: var_names[1] : varin\n: var_names[2] : varout\n: var_names[3] : varenergy\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.find_key_with_value-Tuple{Any,Any}","page":"PowerSimulations","title":"PowerSimulations.find_key_with_value","text":"Return the key for the given value\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.initial_condition_update!-Tuple{Stage,PowerSimulations.ICKey,InterStageChronology,Simulation}","page":"PowerSimulations","title":"PowerSimulations.initial_condition_update!","text":"Updates the initial conditions of the stage\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.initial_condition_update!-Tuple{Stage,PowerSimulations.ICKey,IntraStageChronology,Simulation}","page":"PowerSimulations","title":"PowerSimulations.initial_condition_update!","text":"Updates the initial conditions of the stage\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.instantiate_nip_expr-Tuple{PowerModels.AbstractPowerModel}","page":"PowerSimulations","title":"PowerSimulations.instantiate_nip_expr","text":"\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.instantiate_nip_expr_model-Tuple{Dict{String,Any},Any}","page":"PowerSimulations","title":"PowerSimulations.instantiate_nip_expr_model","text":"\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.instantiate_nip_model-Tuple{Dict{String,Any},Any}","page":"PowerSimulations","title":"PowerSimulations.instantiate_nip_model","text":"\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.integral_limit_ff-Tuple{PowerSimulations.PSIContainer,Symbol,PowerSimulations.UpdateRef,Symbol}","page":"PowerSimulations","title":"PowerSimulations.integral_limit_ff","text":"    integral_limit_ff(psi_container::PSIContainer,\n                    cons_name::Symbol,\n                    param_reference::UpdateRef,\n                    var_name::Symbol)\n\nConstructs a parametrized integral limit constraint to implement feedforward from other models. The Parameters are initialized using the upper boundary values of the provided variables.\n\nConstraints\n\nsum(variable[var_name, t] for t in time_steps)/length(time_steps) <= param_reference[var_name]\n\nLaTeX\n\nsum_t x leq param^max\n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\ncons_name::Symbol : name of the constraint\nparam_reference : Reference to the PJ.ParameterRef used to determine the upperbound\nvar_name::Symbol : the name of the continuous variable\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.powermodels_network!-Union{Tuple{S}, Tuple{PowerSimulations.PSIContainer,Type{S},PowerSystems.System}} where S<:PowerModels.AbstractActivePowerModel","page":"PowerSimulations","title":"PowerSimulations.powermodels_network!","text":"\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.powermodels_network!-Union{Tuple{S}, Tuple{PowerSimulations.PSIContainer,Type{S},PowerSystems.System}} where S<:PowerModels.AbstractPowerModel","page":"PowerSimulations","title":"PowerSimulations.powermodels_network!","text":"\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.ps_cost-Union{Tuple{JV}, Tuple{PowerSimulations.PSIContainer,JuMP.Containers.DenseAxisArray{JV,N,Ax,L} where L<:Tuple{Vararg{Dict,N}} where Ax where N,Float64,Float64,Float64}} where JV<:JuMP.AbstractVariableRef","page":"PowerSimulations","title":"PowerSimulations.ps_cost","text":"ps_cost(psi_container::PSIContainer,\n            variable::JuMP.Containers.DenseAxisArray{JV},\n            cost_component::Float64,\n            dt::Float64,\n            sign::Float64) where {JV <: JuMP.AbstractVariableRef}\n\nReturns linear cost terms for sum of variables with common factor to be used for cost expression for psi_container model.\n\nEquation\n\ngen_cost = sum(variable)*cost_component\n\nLaTeX\n\ncost = dttimes signsum_iin I c x_i\n\nReturns:\n\nsign*gen_cost*dt\n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\nvariable::JuMP.Containers.DenseAxisArray{JV} : variable array\ncost_component::Float64 : cost to be associated with variable\ndt::Float64 : fraction of hour\nsign::Float64 : positive or negative sign to be associated cost term\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.ps_cost-Union{Tuple{JV}, Tuple{PowerSimulations.PSIContainer,JuMP.Containers.DenseAxisArray{JV,N,Ax,L} where L<:Tuple{Vararg{Dict,N}} where Ax where N,PowerSystems.VariableCost{Array{Tuple{Float64,Float64},1}},Float64,Float64}} where JV<:JuMP.AbstractVariableRef","page":"PowerSimulations","title":"PowerSimulations.ps_cost","text":"ps_cost(psi_container::PSIContainer,\n             variable::JuMP.Containers.DenseAxisArray{JV},\n             cost_component::PSY.VariableCost{Vector{NTuple{2, Float64}}},\n             dt::Float64,\n             sign::Float64) where {JV<:JuMP.AbstractVariableRef}\n\nCreates piecewise linear cost function using a sum of variables and expression with sign and time step included.\n\nExpression\n\nJuMP.add_to_expression!(gen_cost, c)\n\nReturns signgen_costdt\n\nLaTeX\n\ncost = signtimes dt sum_vin V c_v\n\nwhere c_v is given by\n\nc_v = sum_iin Ix fracy_i - y_i-1x_i - x_i-1 v^pw_i\n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\nvariable::JuMP.Containers.DenseAxisArray{JV} : variable array\ncost_component::PSY.VariableCost{Vector{NTuple{2, Float64}}}\ndt::Float64 : fraction of hour\nsign::Float64 : positive or negative sign to be associated cost term\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.ps_cost-Union{Tuple{JV}, Tuple{PowerSimulations.PSIContainer,JuMP.Containers.DenseAxisArray{JV,N,Ax,L} where L<:Tuple{Vararg{Dict,N}} where Ax where N,PowerSystems.VariableCost{Float64},Float64,Float64}} where JV<:JuMP.AbstractVariableRef","page":"PowerSimulations","title":"PowerSimulations.ps_cost","text":"ps_cost(psi_container::PSIContainer,\n            variable::JuMP.Containers.DenseAxisArray{JV},\n            cost_component::PSY.VariableCost{Float64},\n            dt::Float64,\n            sign::Float64) where {JV <: JuMP.AbstractVariableRef}\n\nReturns linear cost terms for sum of variables with common factor to be used for cost expression for psicontainer model. Does this by calling ```pscost``` that has Float64 cost component input.\n\nReturns:\n\nps_cost(psi_container, variable, PSY.get_cost(cost_component), dt, sign)\n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\nvariable::JuMP.Containers.DenseAxisArray{JV} : variable array\ncost_component::PSY.VariableCost{Float64} : container for cost to be associated with variable\ndt::Float64 : fraction of hour\nsign::Float64 : positive or negative sign to be associated cost term\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.ps_cost-Union{Tuple{JV}, Tuple{PowerSimulations.PSIContainer,JuMP.Containers.DenseAxisArray{JV,N,Ax,L} where L<:Tuple{Vararg{Dict,N}} where Ax where N,PowerSystems.VariableCost{Tuple{Float64,Float64}},Float64,Float64}} where JV<:JuMP.AbstractVariableRef","page":"PowerSimulations","title":"PowerSimulations.ps_cost","text":"ps_cost(psi_container::PSIContainer,\n            variable::JuMP.Containers.DenseAxisArray{JV},\n            cost_component::PSY.VariableCost{NTuple{2, Float64}}\n            dt::Float64,\n            sign::Float64) where {JV <: JuMP.AbstractVariableRef}\n\nReturns quadratic cost terms for sum of variables with common factor to be used for cost expression for psi_container model.\n\nEquation\n\ngen_cost = dt*sign*(sum(variable.^2)*cost_component[1] + sum(variable)*cost_component[2])\n\nLaTeX\n\ncost = dttimes sign (sum_iin I c_1 v_i^2 + sum_iin I c_2 v_i )\n\nfor quadratic factor large enough. Otherwise\n\nreturn ps_cost(psi_container, variable, cost_component[2], dt, 1.0)\n\nReturns gen_cost\n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\nvariable::JuMP.Containers.DenseAxisArray{JV} : variable array\ncost_component::PSY.VariableCost{NTuple{2, Float64}} : container for quadratic and linear factors\nsign::Float64 : positive or negative sign to be associated cost term\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.ramp_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{T},DeviceModel{T,D},Type{S},Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where S<:PowerModels.AbstractPowerModel where D<:PowerSimulations.AbstractThermalFormulation where T<:PowerSystems.ThermalGen","page":"PowerSimulations","title":"PowerSimulations.ramp_constraints!","text":"This function adds the ramping limits of generators when there are CommitmentVariables\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.range_ff-Tuple{PowerSimulations.PSIContainer,Symbol,Tuple{PowerSimulations.UpdateRef,PowerSimulations.UpdateRef},Symbol}","page":"PowerSimulations","title":"PowerSimulations.range_ff","text":"    range_ff(psi_container::PSIContainer,\n                    cons_name::Symbol,\n                    param_reference::NTuple{2, UpdateRef},\n                    var_name::Symbol)\n\nConstructs min/max range parametrized constraint from device variable to include feedforward.\n\nConstraints\n\nparam_reference[1][var_name] <= variable[var_name, t] variable[var_name, t] <= param_reference[2][var_name]\n\nwhere r in range_data.\n\nLaTeX\n\nparam^min leq x x leq param^max\n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\nparam_reference::NTuple{2, UpdateRef} : Tuple with the lower bound and upper bound parameter reference\ncons_name::Symbol : name of the constraint\nvar_name::Symbol : the name of the continuous variable\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.rating_constraint!-Tuple{PowerSimulations.PSIContainer,Array{Tuple{String,Float64},1},Symbol,Tuple{Symbol,Symbol}}","page":"PowerSimulations","title":"PowerSimulations.rating_constraint!","text":"rating_constraint!(psi_container::PSIContainer,\n                        rating_data::Vector{Tuple{String, Float64}},\n                        cons_name::Symbol,\n                        var_names::Tuple{Symbol, Symbol})\n\nConstructs constraint from rating data and related variable tuple.\n\nConstraint\n\nvar1[r[1], t]^2 + var2[r[1], t]^2 <= r[2]^2\n\nwhere r in rating data and t in time steps.\n\nLaTeX\n\nx_1^2 + x_2^2 leq r^2\n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\nrating_data::Vector{Tuple{String, Float64}} : rating data name (1) and value (2)\ncons_name::Symbol : name of the constraint\nvar_names::Tuple{Symbol, Symbol} : the names of the variables\n: var_names[1] : var1\n: var_names[2] : var2\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.reactive_power_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{St}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{St},DeviceModel{St,D},Type{S},Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where S<:PowerModels.AbstractPowerModel where D<:PowerSimulations.AbstractStorageFormulation where St<:PowerSystems.Storage","page":"PowerSimulations","title":"PowerSimulations.reactive_power_constraints!","text":"This function adds the reactive  power limits of generators when there are CommitmentVariables\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.reactivepower_constraints!-Union{Tuple{L}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{L},DeviceModel{L,#s419} where #s419<:PowerSimulations.AbstractControllablePowerLoadFormulation,Type{#s418} where #s418<:PowerModels.AbstractPowerModel,Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where L<:PowerSystems.ElectricLoad","page":"PowerSimulations","title":"PowerSimulations.reactivepower_constraints!","text":"Reactive Power Constraints on Loads Assume Constant PowerFactor\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.reactivepower_constraints!-Union{Tuple{T}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{T},DeviceModel{T,#s420} where #s420<:PowerSimulations.AbstractThermalDispatchFormulation,Type{#s419} where #s419<:PowerModels.AbstractPowerModel,Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where T<:PowerSystems.ThermalGen","page":"PowerSimulations","title":"PowerSimulations.reactivepower_constraints!","text":"This function adds the reactive  power limits of generators when there are CommitmentVariables\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.reactivepower_constraints!-Union{Tuple{T}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{T},DeviceModel{T,#s420} where #s420<:PowerSimulations.AbstractThermalFormulation,Type{#s419} where #s419<:PowerModels.AbstractPowerModel,Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where T<:PowerSystems.ThermalGen","page":"PowerSimulations","title":"PowerSimulations.reactivepower_constraints!","text":"This function adds the reactive power limits of generators when there CommitmentVariables\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.reactivepower_variables!-Union{Tuple{T}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{T}}} where T<:PowerSystems.ThermalGen","page":"PowerSimulations","title":"PowerSimulations.reactivepower_variables!","text":"This function add the variables for power generation output to the model\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.read_json-Tuple{AbstractString}","page":"PowerSimulations","title":"PowerSimulations.read_json","text":"Return a decoded JSON file.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.remove_chars-Tuple{String,String}","page":"PowerSimulations","title":"PowerSimulations.remove_chars","text":"Removes the string char from the original string\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.replace_chars-Tuple{String,String,String}","page":"PowerSimulations","title":"PowerSimulations.replace_chars","text":"Replaces the string in char with the stringreplacement\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.reserve_device_semicontinuousrange-Tuple{PowerSimulations.PSIContainer,Array{PowerSimulations.DeviceRange,1},Symbol,Symbol,Symbol}","page":"PowerSimulations","title":"PowerSimulations.reserve_device_semicontinuousrange","text":"reserve_device_semicontinuousrange(psi_container::PSIContainer,\n                                range_data::Vector{DeviceRange},\n                                cons_name::Symbol,\n                                var_name::Symbol,\n                                binvar_name::Symbol)\n\nConstructs min/max range constraint from device variable and on/off decision variable.\n\nConstraints\n\nIf device min = 0:\n\nvarcts[name, t] <= limits.max * (1 - varbin[name, t])\n\nvarcts[name, t] >= 0.0\n\nOtherwise:\n\nvarcts[name, t] <= limits.max * (1 - varbin[name, t])\n\nvarcts[name, t] >= limits.min * (1 - varbin[name, t])\n\nwhere limits in range_data.\n\nLaTeX\n\n0 leq x^cts leq limits^max (1 - x^bin ) text for  limits^min = 0\n\nlimits^min (1 - x^bin ) leq x^cts leq limits^max (1 - x^bin ) text otherwise \n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\nrange_data::Vector{DeviceRange} : contains names and vector of min/max\ncons_name::Symbol : name of the constraint\nvar_name::Symbol : the name of the continuous variable\nbinvar_name::Symbol : the name of the binary variable\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.reservoir_energy_balance-Tuple{PowerSimulations.PSIContainer,Array{InitialCondition,1},Array{PowerSimulations.DeviceTimeSeries,1},Symbol,Tuple{Symbol,Symbol,Symbol}}","page":"PowerSimulations","title":"PowerSimulations.reservoir_energy_balance","text":"reservoir_energy_balance(psi_container::PSIContainer,\n                    initial_conditions::Vector{InitialCondition},\n                    efficiency_data::Tuple{Vector{String}, Vector{InOut}},\n                    cons_name::Symbol,\n                    var_names::Tuple{Symbol, Symbol, Symbol})\n\nConstructs multi-timestep constraint from initial condition, efficiency data, and variable tuple\n\nConstraints\n\nIf t = 1: varenergy[name, 1] == initial_conditions[ix].value + (paraminflow[name, t] - varspill[name, 1] - varout[name, 1])*fraction_of_hour If t > 1: varenergy[name, t] == varenergy[name, t-1] + (paraminflow[name, t] - varspill[name, t] - varout[name, t])*fraction_of_hour\n\nLaTeX\n\nx^energy_1 == x^energy_init + frhr  (x^in_1 - x^spillage_1 -  x^out_1) text for  t = 1 x^energy_t == x^energy_t-1 + frhr (x^in_t - x^spillage_t - x^out_t) forall t geq 2\n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\ninitial_conditions::Vector{InitialCondition} : for time zero 'varenergy'\ninflow_data::TVector{DeviceTimeSeries} :: Inflow energy forecast information\ncons_name::Symbol : name of the constraint\nvar_names::Tuple{Symbol, Symbol, Symbol} : the names of the variables\n: var_names[1] : varspill\n: var_names[2] : varout\n: var_names[3] : varenergy\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.reservoir_energy_balance_param-Tuple{PowerSimulations.PSIContainer,Array{InitialCondition,1},Array{PowerSimulations.DeviceTimeSeries,1},Symbol,Tuple{Symbol,Symbol,Symbol},PowerSimulations.UpdateRef}","page":"PowerSimulations","title":"PowerSimulations.reservoir_energy_balance_param","text":"reservoir_energy_balance(psi_container::PSIContainer,\n                    initial_conditions::Vector{InitialCondition},\n                    efficiency_data::Tuple{Vector{String}, Vector{InOut}},\n                    cons_name::Symbol,\n                    var_names::Tuple{Symbol, Symbol, Symbol})\n\nConstructs multi-timestep constraint from initial condition, efficiency data, and variable tuple\n\nConstraints\n\nIf t = 1: varenergy[name, 1] == initial_conditions[ix].value + (paraminflow[name, t] - varspill[name, 1] - varout[name, 1])*fraction_of_hour If t > 1: varenergy[name, t] == varenergy[name, t-1] + (paraminflow[name, t] - varspill[name, t] - varout[name, t])*fraction_of_hour\n\nLaTeX\n\nx^energy_1 == x^energy_init + frhr  (x^in_1 - x^spillage_1 -  x^out_1) text for  t = 1 x^energy_t == x^energy_t-1 + frhr (x^in_t - x^spillage_t - x^out_t) forall t geq 2\n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\ninitial_conditions::Vector{InitialCondition} : for time zero 'varenergy'\ninflow_data::Vector{DeviceTimeSeries} :: Inflow energy forecast information\ncons_name::Symbol : name of the constraint\nvar_names::Tuple{Symbol, Symbol, Symbol} : the names of the variables\n: var_names[1] : varspill\n: var_names[2] : varout\n: var_names[3] : varenergy\nparam_reference::UpdateRef : UpdateRef to access the inflow parameter\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.semicontinuousrange_ff-Tuple{PowerSimulations.PSIContainer,Symbol,PowerSimulations.UpdateRef,Symbol}","page":"PowerSimulations","title":"PowerSimulations.semicontinuousrange_ff","text":"        semicontinuousrange_ff(psi_container::PSIContainer,\n                                cons_name::Symbol,\n                                var_name::Symbol,\n                                param_reference::UpdateRef)\n\nConstructs min/max range constraint from device variable with parameter setting.\n\nConstraints\n\nIf device min = 0:\n\nvariable[var_name, t] <= r[2].max*param_reference[var_name]\n\nOtherwise:\n\nvariable[var_name, t] <= r[2].max*param_reference[var_name]\n\nvariable[var_name, t] >= r[2].min*param_reference[var_name]\n\nwhere r in range_data.\n\nLaTeX\n\n00 leq x^var leq r^max x^param text for  r^min = 0\n\nr^min x^param leq x^var leq r^min x^param text otherwise \n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\ncons_name::Symbol : name of the constraint\nvar_name::Symbol : the name of the continuous variable\nparam_reference::UpdateRef : UpdateRef of the parameter\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.set_variable_bounds!-Union{Tuple{T}, Tuple{PowerSimulations.PSIContainer,Array{PowerSimulations.DeviceRange,1},AbstractString,Type{T}}} where T<:PowerSystems.Device","page":"PowerSimulations","title":"PowerSimulations.set_variable_bounds!","text":"set_variable_bounds!(\n    psi_container::PSIContainer,\n    bounds::DeviceRange,\n    var_type::AbstractString,\n    device_type::Type{PSY.Device},\n)\n\nAdds a bounds to a variable in the optimization model.\n\nBounds\n\nbounds.min <= varstart[name, t] <= bounds.max\n\nLaTeX\n\nx^device_t = bound^min forall t\n\nx^device_t = bound^max forall t\n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\nbounds::DeviceRange : contains names and vector of min / max\nvar_type::AbstractString : type of the variable\nT: type of the device\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.status_init-Union{Tuple{T}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{T}}} where T<:PowerSystems.ThermalGen","page":"PowerSimulations","title":"PowerSimulations.status_init","text":"Status Init is always calculated based on the Power Output of the device This is to make it easier to calculate when the previous model doesn't contain binaries. For instance, looking back on an ED model to find the IC of the UC model\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.ub_ff-Tuple{PowerSimulations.PSIContainer,Symbol,PowerSimulations.UpdateRef,Symbol}","page":"PowerSimulations","title":"PowerSimulations.ub_ff","text":"    ub_ff(psi_container::PSIContainer,\n          cons_name::Symbol,\n          param_reference::UpdateRef,\n          var_name::Symbol)\n\nConstructs a parametrized upper bound constraint to implement feedforward from other models. The Parameters are initialized using the uppper boundary values of the provided variables.\n\nConstraints\n\nvariable[var_name, t] <= param_reference[var_name]\n\nLaTeX\n\nx leq param^max\n\nArguments\n\npsicontainer::PSIContainer : the psicontainer model built in PowerSimulations\ncons_name::Symbol : name of the constraint\nparam_reference : Reference to the PJ.ParameterRef used to determine the upperbound\nvar_name::Symbol : the name of the continuous variable\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.update_parameter!-Tuple{PowerSimulations.UpdateRef{JuMP.VariableRef},PowerSimulations.ParameterContainer,Stage,Simulation}","page":"PowerSimulations","title":"PowerSimulations.update_parameter!","text":"Updates the forecast parameter value\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.update_stage!-Union{Tuple{M}, Tuple{Stage{M},Simulation}} where M<:PowerSimulations.AbstractOperationsProblem","page":"PowerSimulations","title":"PowerSimulations.update_stage!","text":"Generic Stage update function for most problems with no customization\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.variable_active_net_injection-Tuple{PowerModels.AbstractPowerModel}","page":"PowerSimulations","title":"PowerSimulations.variable_active_net_injection","text":"\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.variable_net_injection-Tuple{PowerModels.AbstractPowerModel}","page":"PowerSimulations","title":"PowerSimulations.variable_net_injection","text":"generates variables for both active and reactive net injection\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.variable_reactive_net_injection-Tuple{PowerModels.AbstractActivePowerModel}","page":"PowerSimulations","title":"PowerSimulations.variable_reactive_net_injection","text":"active power only models ignore reactive power variables\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations.html#PowerSimulations.variable_reactive_net_injection-Tuple{PowerModels.AbstractPowerModel}","page":"PowerSimulations","title":"PowerSimulations.variable_reactive_net_injection","text":"\n\n\n\n","category":"method"},{"location":"glossary.html#Glossary-1","page":"Glossary","title":"Glossary","text":"","category":"section"},{"location":"glossary.html#Simulation-Sequence-Components-1","page":"Glossary","title":"Simulation Sequence Components","text":"","category":"section"},{"location":"glossary.html#","page":"Glossary","title":"Glossary","text":"cache: Cache is used to store quantities resulting from the solutions of a stage.","category":"page"},{"location":"glossary.html#","page":"Glossary","title":"Glossary","text":"chronology: The vertical inter-stage relationship dictating how variable results impact the next stage's variable parameters.","category":"page"},{"location":"glossary.html#","page":"Glossary","title":"Glossary","text":"Example: feedforward_chronologies = Dict((\"stage-1\" => \"stage-2\") => Synchronize(periods = 24)) This chronology uses the first 24 solutions in the horizon to synchronize with 24 executions of stage 2.","category":"page"},{"location":"glossary.html#","page":"Glossary","title":"Glossary","text":"feedforward: The variable that is used as a parameter for a later stage.","category":"page"},{"location":"glossary.html#","page":"Glossary","title":"Glossary","text":"Example: feedforward = Dict((\"stage-2\", :devices, :Generators) => SemiContinuousFF(binary_from_stage = PSI.ON, affected_variables = [PSI.ACTIVE_POWER]) This semi-continuous feedforward passes binary results from the first stage to parameters of the active power of the second stage.","category":"page"},{"location":"glossary.html#","page":"Glossary","title":"Glossary","text":"horizons: The integer count of resolution time periods for a full step resolution of the simulation. (Horizon = 12) x (resolution = 1 Hour) = 12 Hours","category":"page"},{"location":"glossary.html#","page":"Glossary","title":"Glossary","text":"Example: horizons = Dict(\"stage-1\" => 24, \"stage-2\" => 12) The first stage has a horizon of 24, representing 24 1-hour increments. The second stage has a horizon of 12, representing 12 5-min increments","category":"page"},{"location":"glossary.html#","page":"Glossary","title":"Glossary","text":"initial condition chronology: The structure dictating how initial conditions get updated from previous results in the simulation.","category":"page"},{"location":"glossary.html#","page":"Glossary","title":"Glossary","text":"Examples: ini_cond_chronology = InterStageChronology()","category":"page"},{"location":"glossary.html#","page":"Glossary","title":"Glossary","text":"1\n|\n2                   2 ... (x04)\n|             ----/|\n|             |     |\n3 --> 3 ... (x12)   3 --> 3 ... (x12)","category":"page"},{"location":"glossary.html#","page":"Glossary","title":"Glossary","text":"This represents an inter-stage chronology where the results of each stage feed back into the initial conditions of the stage above it.","category":"page"},{"location":"glossary.html#","page":"Glossary","title":"Glossary","text":"ini_cond_chronology = IntraStageChronology()","category":"page"},{"location":"glossary.html#","page":"Glossary","title":"Glossary","text":"1\n\n2 ----------------> 2 ... (x04)\n\n3 --> 3 ... (x12)   3 --> 3 ... (x12)","category":"page"},{"location":"glossary.html#","page":"Glossary","title":"Glossary","text":"This represents an intra-stage chronology where the results of each simulation run feed back into the initial conditions of the next simulation for that stage.","category":"page"},{"location":"glossary.html#","page":"Glossary","title":"Glossary","text":"intervals: The increment of time per stage in each simulation solve, and how results get fed forward into initial conditions between intervals.","category":"page"},{"location":"glossary.html#","page":"Glossary","title":"Glossary","text":"Example: intervals = Dict(\"UC\" => (Hour(24), Consecutive()), \"ED\" => (Hour(1), Consecutive()))","category":"page"},{"location":"glossary.html#","page":"Glossary","title":"Glossary","text":"Operations Problem A single-step optimization problem.","category":"page"},{"location":"glossary.html#","page":"Glossary","title":"Glossary","text":"Simulations Problem: A multi-step and/or multi-stage optimization problem.","category":"page"},{"location":"glossary.html#","page":"Glossary","title":"Glossary","text":"Simulation Sequence: Simulation Sequence formulates the structure and flow of results through the simulation. It sets up the feedforward and initial condition chronologies, the horizon, intervals, and order.","category":"page"},{"location":"glossary.html#","page":"Glossary","title":"Glossary","text":"Stage: Each stage represents a formulation of a problem to be solved, such as unit commitment or economic dispatch. Each stage has its own system with a specified time-scale.","category":"page"},{"location":"glossary.html#","page":"Glossary","title":"Glossary","text":"Example:","category":"page"},{"location":"glossary.html#","page":"Glossary","title":"Glossary","text":"\"UC\" => Stage(GenericOpProblem, template, system, optimizer)","category":"page"},{"location":"glossary.html#","page":"Glossary","title":"Glossary","text":"problem: The optimization problem populated with the specific system to be solved.","category":"page"},{"location":"glossary.html#","page":"Glossary","title":"Glossary","text":"step resolution: The time period representing the time length of the whole simulation before it repeats.","category":"page"},{"location":"glossary.html#","page":"Glossary","title":"Glossary","text":"Example: step_resolution = Hour(24)","category":"page"},{"location":"glossary.html#","page":"Glossary","title":"Glossary","text":"template: The structure of the problem to be solved, without the actual system data that makes it a populated problem.","category":"page"},{"location":"glossary.html#","page":"Glossary","title":"Glossary","text":"Time Increments: ***Resolution  Interval  Step Resolution***","category":"page"},{"location":"index.html#PowerSimulations.jl-1","page":"Introduction","title":"PowerSimulations.jl","text":"","category":"section"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"CurrentModule = PowerSimulations","category":"page"},{"location":"index.html#Overview-1","page":"Introduction","title":"Overview","text":"","category":"section"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"PowerSimulations.jl is a Julia/JuMP package designed to develop and study power system operation models in steady-state. It uses the data model implemented in PowerSystems.jl to construct optimization models.","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"The package supports to major analysis tools.","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"Operational Models: Meant to study and analyze multiperiod operational model formulations that can specified by the combination of device formulations and network models.\nSimulations Models: Developed to run equences of operational models to study model interactions sucha as cost-production-modeling.","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"The documentation is still work in progress.","category":"page"},{"location":"index.html#Installation-1","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"The latest stable release of PowerModels can be installed using the Julia package manager with","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"] add PowerSimulations","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"For the current development version, \"checkout\" this package with","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"] add PowerSimulations#master","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"An appropiate optimization solver is required for running PowerSimulations models. Refer to JuMP.jl solver's page to select the most appropiate for the application of interest.","category":"page"},{"location":"man/op_problem.html#Operational-Model-1","page":"Operation Model","title":"Operational Model","text":"","category":"section"},{"location":"man/op_problem.html#","page":"Operation Model","title":"Operation Model","text":"An operational model is defined as the combination of an objective function (\\refeq{gpsimulations}) in terms of state x and control u variables. Equations (\\refeq{dpsimulations}) describe the device model formulations as a function of variables, parameters eta and uncertainty terms omega. Further, equations (\\refeq{n_psimulations}) represents the network modeling and finally the system services.","category":"page"},{"location":"man/op_problem.html#","page":"Operation Model","title":"Operation Model","text":"In the same fashion as in PowerSystems.jl, the objective is not to list all possible formulations for devices, network, and services in a power system model. Rather, the contribution is to develop a type hierarchy that enables developers to create new formulations and allow analysts a  natural way to describe the functional assumptions used in the model.","category":"page"}]
}
